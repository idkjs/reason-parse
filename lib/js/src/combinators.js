// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Char = require("bs-platform/lib/js/char.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function stringOfResult(result) {
  if (typeof result === "number") {
    return "Nothing";
  } else {
    switch (result.tag | 0) {
      case 0 : 
          return "'" + (Char.escaped(result[0]) + "'");
      case 1 : 
          return result[0];
      case 2 : 
          return "[" + ($$Array.of_list(List.map(stringOfResult, result[0])).join(", ") + "]");
      
    }
  }
}

function map(f, p, s) {
  var x = Curry._1(p, s);
  if (x.tag) {
    return x;
  } else {
    return /* Success */Block.__(0, [
              Curry._1(f, x[0]),
              x[1]
            ]);
  }
}

function stringOfOutput(output) {
  if (output.tag) {
    return "Fail: " + output[0];
  } else {
    return "Result: " + (stringOfResult(output[0]) + (", Leftover: " + output[1]));
  }
}

function succeedWith(result, s) {
  return /* Success */Block.__(0, [
            result,
            s
          ]);
}

function fail(message, _) {
  return /* Fail */Block.__(1, [message]);
}

function satisfy(f, s) {
  var match = s.length;
  if (match !== 0) {
    var match$1 = Curry._1(f, Caml_string.get(s, 0));
    if (match$1 !== 0) {
      return /* Success */Block.__(0, [
                /* Chr */Block.__(0, [Caml_string.get(s, 0)]),
                $$String.sub(s, 1, s.length - 1 | 0)
              ]);
    } else {
      return /* Fail */Block.__(1, ["s.[0] does not satisfy predicate."]);
    }
  } else {
    return /* Fail */Block.__(1, ["Parsing empty string!"]);
  }
}

function character(a) {
  return (function (param) {
      return satisfy((function (param) {
                    return +(a === param);
                  }), param);
    });
}

function seq(ps, s) {
  if (ps) {
    var match = Curry._1(ps[0], s);
    if (match.tag) {
      return /* Fail */Block.__(1, ["One of the parsers in the sequence failed."]);
    } else {
      var match$1 = seq(ps[1], match[1]);
      if (match$1.tag) {
        return /* Fail */Block.__(1, ["One of the parsers in the sequence failed."]);
      } else {
        var match$2 = match$1[0];
        if (typeof match$2 === "number") {
          return /* Fail */Block.__(1, ["One of the parsers in the sequence failed."]);
        } else if (match$2.tag === 2) {
          return /* Success */Block.__(0, [
                    /* Seq */Block.__(2, [/* :: */[
                          match[0],
                          match$2[0]
                        ]]),
                    match$1[1]
                  ]);
        } else {
          return /* Fail */Block.__(1, ["One of the parsers in the sequence failed."]);
        }
      }
    }
  } else {
    return /* Success */Block.__(0, [
              /* Seq */Block.__(2, [/* [] */0]),
              s
            ]);
  }
}

function $great$great$great(p, q) {
  var partial_arg_001 = /* :: */[
    q,
    /* [] */0
  ];
  var partial_arg = /* :: */[
    p,
    partial_arg_001
  ];
  return (function (param) {
      return seq(partial_arg, param);
    });
}

function alt(_ps, s) {
  while(true) {
    var ps = _ps;
    if (ps) {
      var x = Curry._1(ps[0], s);
      if (x.tag) {
        _ps = ps[1];
        continue ;
        
      } else {
        return x;
      }
    } else {
      return /* Fail */Block.__(1, ["None of the parsers matched."]);
    }
  };
}

function $less$pipe$great(p, q) {
  var partial_arg_001 = /* :: */[
    q,
    /* [] */0
  ];
  var partial_arg = /* :: */[
    p,
    partial_arg_001
  ];
  return (function (param) {
      return alt(partial_arg, param);
    });
}

function toCharList(s) {
  return $$Array.to_list(s.split("").map((function (t) {
                    return Caml_string.get(t, 0);
                  })));
}

function charInString(s) {
  var partial_arg = List.map(character, toCharList(s));
  return (function (param) {
      return alt(partial_arg, param);
    });
}

var letter = charInString("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");

var digit = charInString("0123456789");

function inclusiveRange(m, n) {
  if (m < n) {
    return /* :: */[
            m,
            inclusiveRange(m + 1 | 0, n)
          ];
  } else if (m > n) {
    return /* :: */[
            m,
            inclusiveRange(m - 1 | 0, n)
          ];
  } else {
    return /* :: */[
            m,
            /* [] */0
          ];
  }
}

function concatCharList(charList) {
  return $$Array.of_list(List.map(Char.escaped, charList)).join("");
}

function unwrapSeq(result) {
  if (typeof result === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "combinators.re",
            103,
            9
          ]
        ];
  } else if (result.tag === 2) {
    return result[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "combinators.re",
            103,
            9
          ]
        ];
  }
}

function unwrapChr(result) {
  if (typeof result === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "combinators.re",
            109,
            9
          ]
        ];
  } else if (result.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "combinators.re",
            109,
            9
          ]
        ];
  } else {
    return result[0];
  }
}

function wrapStr(s) {
  return /* Str */Block.__(1, [s]);
}

function thisString(s) {
  var partial_arg = List.map(character, toCharList(s));
  var partial_arg$1 = function (param) {
    return seq(partial_arg, param);
  };
  return (function (param) {
      return map((function (result) {
                    return /* Str */Block.__(1, [concatCharList(List.map(unwrapChr, unwrapSeq(result)))]);
                  }), partial_arg$1, param);
    });
}

function charInRange(m, n) {
  var partial_arg = List.map(character, List.map(Char.chr, inclusiveRange(m, n)));
  return (function (param) {
      return alt(partial_arg, param);
    });
}

function times(_$staropt$star, _$staropt$star$1, atMost, p, _s) {
  while(true) {
    var s = _s;
    var $staropt$star = _$staropt$star$1;
    var $staropt$star$1 = _$staropt$star;
    var results = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
    var atLeast = $staropt$star ? $staropt$star[0] : 0;
    if (atLeast > atMost) {
      Js_exn.raiseError("atLeast > atMost??");
    }
    var count = List.length(results);
    var match = Curry._1(p, s);
    if (match.tag) {
      if (atLeast <= count && count <= atMost) {
        return /* Success */Block.__(0, [
                  /* Seq */Block.__(2, [results]),
                  s
                ]);
      } else if (count < atLeast) {
        return /* Fail */Block.__(1, ["Didn't match enough times."]);
      } else {
        return Js_exn.raiseError("count > atMost??");
      }
    } else if (count < atMost) {
      _s = match[1];
      _$staropt$star$1 = /* Some */[atLeast];
      _$staropt$star = /* Some */[/* :: */[
          match[0],
          results
        ]];
      continue ;
      
    } else if (count === atMost) {
      return /* Fail */Block.__(1, ["Matched too many times."]);
    } else {
      return Js_exn.raiseError("count > atMost??");
    }
  };
}

exports.stringOfResult = stringOfResult;
exports.map = map;
exports.stringOfOutput = stringOfOutput;
exports.succeedWith = succeedWith;
exports.fail = fail;
exports.satisfy = satisfy;
exports.character = character;
exports.seq = seq;
exports.$great$great$great = $great$great$great;
exports.alt = alt;
exports.$less$pipe$great = $less$pipe$great;
exports.toCharList = toCharList;
exports.charInString = charInString;
exports.letter = letter;
exports.digit = digit;
exports.inclusiveRange = inclusiveRange;
exports.concatCharList = concatCharList;
exports.unwrapSeq = unwrapSeq;
exports.unwrapChr = unwrapChr;
exports.wrapStr = wrapStr;
exports.thisString = thisString;
exports.charInRange = charInRange;
exports.times = times;
/* letter Not a pure module */
