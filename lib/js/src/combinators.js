// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Stream = require("bs-platform/lib/js/stream.js");

function nextOpt(stream) {
  try {
    return /* Some */[Stream.next(stream)];
  }
  catch (exn){
    if (exn === Stream.Failure) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function alt(stream, string) {
  while(true) {
    var match = nextOpt(stream);
    if (match) {
      var success = Curry._1(match[0], string);
      if (success[0] >= 781116926) {
        continue ;
        
      } else {
        return success;
      }
    } else {
      return /* `Fail */[
              781116926,
              "None of the parsers matched"
            ];
    }
  };
}

function tillFailure(stream, string) {
  var match = nextOpt(stream);
  if (match) {
    var success = Curry._1(match[0], string);
    if (success[0] >= 781116926) {
      return /* tuple */[
              /* [] */0,
              /* Some */[success]
            ];
    } else {
      var match$1 = tillFailure(stream, success[1][1][/* remainder */1]);
      return /* tuple */[
              /* :: */[
                success,
                match$1[0]
              ],
              match$1[1]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* None */0
          ];
  }
}

function mergeParseData(initialString, list) {
  if (list) {
    var x = list[0];
    return /* record */[
            /* match */mergeParseData(initialString, list[1])[/* match */0] + x[/* match */0],
            /* remainder */x[/* remainder */1]
          ];
  } else {
    return /* record */[
            /* match */"",
            /* remainder */initialString
          ];
  }
}

function tillFailureMerged(stream, string) {
  var match = tillFailure(stream, string);
  var match$1 = List.split(List.map((function (param) {
              var match = param[1];
              return /* tuple */[
                      match[0],
                      match[1]
                    ];
            }), match[0]));
  return /* tuple */[
          List.rev(match$1[0]),
          mergeParseData(string, match$1[1]),
          match[1]
        ];
}

function stream(stream$1, string) {
  var match = tillFailureMerged(stream$1, string);
  var match$1 = match[2];
  if (match$1) {
    return /* `Fail */[
            781116926,
            /* :: */[
              Curry._1(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser `Stream failure at parser index ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "Parser `Stream failure at parser index %d"
                      ]), Stream.count(stream$1)),
              match$1[0][1]
            ]
          ];
  } else {
    return /* `Success */[
            94326179,
            /* tuple */[
              /* `List */[
                848054398,
                match[0]
              ],
              match[1]
            ]
          ];
  }
}

function seq(ps) {
  var partial_arg = Stream.of_list(ps);
  return (function (param) {
      return stream(partial_arg, param);
    });
}

function appendRange(list) {
  return List.mapi((function (i, a) {
                return /* tuple */[
                        i,
                        a
                      ];
              }), list);
}

function filteri(predicate, list) {
  return List.map((function (prim) {
                return prim[1];
              }), List.filter((function (param) {
                      return Curry._2(predicate, param[0], param[1]);
                    }))(appendRange(list)));
}

function keep(indices, ps, s) {
  var partial_arg = Stream.of_list(ps);
  var fail = (function (param) {
        return stream(partial_arg, param);
      })(s);
  if (typeof fail === "number") {
    return fail;
  } else if (fail[0] !== 94326179) {
    return fail;
  } else {
    var match = fail[1];
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      return fail;
    } else if (match$1[0] !== 848054398) {
      return fail;
    } else {
      var filteredList = filteri((function (i, _) {
              return List.mem(i, indices);
            }), match$1[1]);
      return /* `Success */[
              94326179,
              /* tuple */[
                /* `List */[
                  848054398,
                  filteredList
                ],
                match[1]
              ]
            ];
    }
  }
}

function keepNth(n, ps) {
  var partial_arg = /* :: */[
    n,
    /* [] */0
  ];
  return (function (param) {
      return keep(partial_arg, ps, param);
    });
}

function keepFirst(ps) {
  return keepNth(0, ps);
}

function keepLast(ps) {
  return keepNth(List.length(ps) - 1 | 0, ps);
}

function between(p, q, r) {
  return keepNth(1, /* :: */[
              p,
              /* :: */[
                q,
                /* :: */[
                  r,
                  /* [] */0
                ]
              ]
            ]);
}

function successes($staropt$star, stream, string) {
  var atLeast = $staropt$star ? $staropt$star[0] : 0;
  var match = tillFailureMerged(stream, string);
  var failOpt = match[2];
  var pRec = match[1];
  var values = match[0];
  var n = List.length(values);
  if (failOpt) {
    var match$1 = +(n >= atLeast);
    if (match$1 !== 0) {
      return /* `Success */[
              94326179,
              /* tuple */[
                /* `List */[
                  848054398,
                  values
                ],
                pRec
              ]
            ];
    } else {
      return /* `Fail */[
              781116926,
              /* :: */[
                "Parse failed too soon",
                failOpt[0][1]
              ]
            ];
    }
  } else {
    var match$2 = +(n >= atLeast);
    if (match$2 !== 0) {
      return /* `Success */[
              94326179,
              /* tuple */[
                /* `List */[
                  848054398,
                  values
                ],
                pRec
              ]
            ];
    } else {
      return /* `Fail */[
              781116926,
              /* :: */[
                "Stream ended too soon.",
                /* [] */0
              ]
            ];
    }
  }
}

function _times($staropt$star, atMost, parser) {
  var atLeast = $staropt$star ? $staropt$star[0] : 0;
  var partial_arg = Stream.from((function (n) {
          if (atMost) {
            if (n < atMost[0]) {
              return /* Some */[parser];
            } else {
              return /* None */0;
            }
          } else {
            return /* Some */[parser];
          }
        }));
  var partial_arg$1 = /* Some */[atLeast];
  return (function (param) {
      return successes(partial_arg$1, partial_arg, param);
    });
}

function zeroOrMore(parser) {
  return _times(/* Some */[0], /* None */0, parser);
}

function oneOrMore(parser) {
  return _times(/* Some */[1], /* None */0, parser);
}

function atLeast(atLeast$1, parser) {
  return _times(/* Some */[atLeast$1], /* None */0, parser);
}

function atMost(atMost$1) {
  var partial_arg = /* Some */[atMost$1];
  var partial_arg$1 = /* Some */[0];
  return (function (param) {
      return _times(partial_arg$1, partial_arg, param);
    });
}

function atLeastAtMost(atLeast, atMost) {
  var partial_arg = /* Some */[atMost];
  var partial_arg$1 = /* Some */[atLeast];
  return (function (param) {
      return _times(partial_arg$1, partial_arg, param);
    });
}

function nTimes(n) {
  return atLeastAtMost(n, n);
}

function sepBy(separator, parser, string) {
  var stream = Stream.from((function (n) {
          var match = +(n === 0);
          if (match !== 0) {
            return /* Some */[parser];
          } else {
            return /* Some */[keepLast(/* :: */[
                          separator,
                          /* :: */[
                            parser,
                            /* [] */0
                          ]
                        ])];
          }
        }));
  return successes(/* Some */[0], stream, string);
}

exports.nextOpt = nextOpt;
exports.alt = alt;
exports.tillFailure = tillFailure;
exports.mergeParseData = mergeParseData;
exports.tillFailureMerged = tillFailureMerged;
exports.stream = stream;
exports.seq = seq;
exports.appendRange = appendRange;
exports.filteri = filteri;
exports.keep = keep;
exports.keepNth = keepNth;
exports.keepFirst = keepFirst;
exports.keepLast = keepLast;
exports.between = between;
exports.successes = successes;
exports._times = _times;
exports.zeroOrMore = zeroOrMore;
exports.oneOrMore = oneOrMore;
exports.atLeast = atLeast;
exports.atMost = atMost;
exports.atLeastAtMost = atLeastAtMost;
exports.nTimes = nTimes;
exports.sepBy = sepBy;
/* Format Not a pure module */
