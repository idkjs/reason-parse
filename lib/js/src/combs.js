// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Node$ReasonParse = require("./node.js");

function map(f, p, s) {
  var f$1 = Curry._1(p, s);
  if (f$1.tag) {
    return f$1;
  } else {
    return /* Node */Block.__(0, [Curry._1(f, f$1[0])]);
  }
}

function alt(_parsers, s) {
  while(true) {
    var parsers = _parsers;
    if (parsers) {
      var n = Curry._1(parsers[0], s);
      if (n.tag) {
        _parsers = parsers[1];
        continue ;
        
      } else {
        return n;
      }
    } else {
      return /* Fail */Block.__(1, ["Alt failed. (Did you pass it an empty list?)"]);
    }
  };
}

function success(value, s) {
  return /* Node */Block.__(0, [/* record */[
              /* value */value,
              /* parseData */Node$ReasonParse.makeParseData(/* None */0, "", s, /* () */0)
            ]]);
}

function concatMatches(nodeList) {
  return $$Array.of_list(List.map((function (node) {
                      return node[/* parseData */1][/* match */0];
                    }), nodeList)).join("");
}

function seq(parsers, s) {
  if (parsers) {
    var f = Curry._1(parsers[0], s);
    if (f.tag) {
      return f;
    } else {
      var node = f[0];
      var f$1 = seq(parsers[1], node[/* parseData */1][/* rest */1]);
      if (f$1.tag) {
        return f$1;
      } else {
        var listNode = f$1[0];
        var match = listNode[/* value */0];
        if (typeof match === "number") {
          return Js_exn.raiseTypeError("This should always be a list.");
        } else if (match.tag === 3) {
          var childNodes = match[0];
          var init = listNode[/* parseData */1];
          return /* Node */Block.__(0, [/* record */[
                      /* value : Lst */Block.__(3, [/* :: */[
                            node,
                            childNodes
                          ]]),
                      /* parseData : record */[
                        /* match */concatMatches(/* :: */[
                              node,
                              childNodes
                            ]),
                        /* rest */init[/* rest */1],
                        /* parserName */init[/* parserName */2]
                      ]
                    ]]);
        } else {
          return Js_exn.raiseTypeError("This should always be a list.");
        }
      }
    }
  } else {
    return success(/* Lst */Block.__(3, [/* [] */0]), s);
  }
}

exports.map = map;
exports.alt = alt;
exports.success = success;
exports.concatMatches = concatMatches;
exports.seq = seq;
/* Node-ReasonParse Not a pure module */
