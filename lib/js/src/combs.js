// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Node$ReasonParse = require("./node.js");

function map($staropt$star, $staropt$star$1, p, s) {
  var f = $staropt$star ? $staropt$star[0] : (function (x) {
        return x;
      });
  var g = $staropt$star$1 ? $staropt$star$1[0] : (function (x) {
        return x;
      });
  var x = Curry._1(p, s);
  if (x.tag) {
    return x;
  } else {
    return /* Success */Block.__(0, [
              Curry._1(f, x[0]),
              Curry._1(g, x[1])
            ]);
  }
}

function alt(_parsers, s) {
  while(true) {
    var parsers = _parsers;
    if (parsers) {
      var s$1 = Curry._1(parsers[0], s);
      if (s$1.tag) {
        _parsers = parsers[1];
        continue ;
        
      } else {
        return s$1;
      }
    } else {
      return /* Fail */Block.__(1, ["Alt failed. (Did you pass it an empty list?)"]);
    }
  };
}

function success(value, s) {
  return /* Success */Block.__(0, [
            value,
            Node$ReasonParse.makeParseData(/* None */0, "", s, /* () */0)
          ]);
}

function fail(message, _) {
  return /* Fail */Block.__(1, [message]);
}

function flatten(value) {
  if (typeof value === "number" || value.tag !== 3) {
    return value;
  } else {
    return /* Lst */Block.__(3, [List.fold_right((function (v, acc) {
                      if (typeof v === "number") {
                        return /* :: */[
                                v,
                                acc
                              ];
                      } else if (v.tag === 3) {
                        return List.append(acc, v[0]);
                      } else {
                        return /* :: */[
                                v,
                                acc
                              ];
                      }
                    }), value[0], /* [] */0)]);
  }
}

function preSeq(parsers, s) {
  if (parsers) {
    var match = Curry._1(parsers[0], s);
    if (match.tag) {
      return /* tuple */[
              /* [] */0,
              /* [] */0
            ];
    } else {
      var parseData = match[1];
      var match$1 = preSeq(parsers[1], parseData[/* rest */1]);
      return /* tuple */[
              /* :: */[
                match[0],
                match$1[0]
              ],
              /* :: */[
                parseData,
                match$1[1]
              ]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function seq(parsers, s) {
  var match = preSeq(parsers, s);
  var parseDataList = match[1];
  var valueList = match[0];
  var m = List.length(valueList);
  var n = List.length(parsers);
  if (m < n) {
    return /* Fail */Block.__(1, [Curry._2(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    " of ",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            " failed.",
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "Parser %d of %d failed."
                      ]), m + 1 | 0, n)]);
  } else {
    var match_ = $$Array.of_list(List.map((function (param) {
                  return param[/* match */0];
                }), parseDataList)).join("");
    var parseData = List.hd(List.rev(parseDataList));
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [valueList]),
              /* record */[
                /* match */match_,
                /* rest */parseData[/* rest */1],
                /* parserName */parseData[/* parserName */2]
              ]
            ]);
  }
}

function maybe(p, s) {
  var s$1 = Curry._1(p, s);
  if (s$1.tag) {
    return success(/* Nil */0, s);
  } else {
    return s$1;
  }
}

function zeroOrMore(p, s) {
  var match = Curry._1(p, s);
  if (match.tag) {
    return success(/* Lst */Block.__(3, [/* [] */0]), s);
  } else {
    var parseData = match[1];
    var match$1 = zeroOrMore(p, parseData[/* rest */1]);
    if (match$1.tag) {
      return Js_exn.raiseError("zeroOrMore should never fail!");
    } else {
      var moreParseData = match$1[1];
      return /* Success */Block.__(0, [
                flatten(/* Lst */Block.__(3, [/* :: */[
                          match[0],
                          /* :: */[
                            match$1[0],
                            /* [] */0
                          ]
                        ]])),
                /* record */[
                  /* match */parseData[/* match */0] + moreParseData[/* match */0],
                  /* rest */moreParseData[/* rest */1],
                  /* parserName */moreParseData[/* parserName */2]
                ]
              ]);
    }
  }
}

function oneOrMore(p) {
  var partial_arg_001 = /* :: */[
    (function (param) {
        return zeroOrMore(p, param);
      }),
    /* [] */0
  ];
  var partial_arg = /* :: */[
    p,
    partial_arg_001
  ];
  var partial_arg$1 = function (param) {
    return seq(partial_arg, param);
  };
  var partial_arg$2 = /* Some */[flatten];
  return (function (param) {
      return map(partial_arg$2, /* None */0, partial_arg$1, param);
    });
}

exports.map = map;
exports.alt = alt;
exports.success = success;
exports.fail = fail;
exports.flatten = flatten;
exports.preSeq = preSeq;
exports.seq = seq;
exports.maybe = maybe;
exports.zeroOrMore = zeroOrMore;
exports.oneOrMore = oneOrMore;
/* Format Not a pure module */
