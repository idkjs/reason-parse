// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Node$ReasonParse = require("./node.js");

function map(f, p, s) {
  var x = Curry._1(p, s);
  if (x.tag) {
    return x;
  } else {
    return /* Success */Block.__(0, [
              Curry._1(f, x[0]),
              x[1]
            ]);
  }
}

function alt(_parsers, s) {
  while(true) {
    var parsers = _parsers;
    if (parsers) {
      var s$1 = Curry._1(parsers[0], s);
      if (s$1.tag) {
        _parsers = parsers[1];
        continue ;
        
      } else {
        return s$1;
      }
    } else {
      return /* Fail_ */Block.__(1, ["Alt failed. (Did you pass it an empty list?)"]);
    }
  };
}

function success(value, s) {
  return /* Success */Block.__(0, [
            value,
            Node$ReasonParse.makeParseData(/* None */0, "", s, /* () */0)
          ]);
}

function seq(parsers, s) {
  if (parsers) {
    var f = Curry._1(parsers[0], s);
    if (f.tag) {
      return f;
    } else {
      var parseData = f[1];
      var f$1 = seq(parsers[1], parseData[/* rest */1]);
      if (f$1.tag) {
        return f$1;
      } else {
        var moreParseData = f$1[1];
        var valueList = f$1[0];
        if (typeof valueList === "number" || valueList.tag !== 3) {
          return Js_exn.raiseTypeError("This should always be a list.");
        } else {
          return /* Success */Block.__(0, [
                    /* Lst */Block.__(3, [/* :: */[
                          f[0],
                          valueList[0]
                        ]]),
                    /* record */[
                      /* match */parseData[/* match */0] + moreParseData[/* match */0],
                      /* rest */moreParseData[/* rest */1],
                      /* parserName */moreParseData[/* parserName */2]
                    ]
                  ]);
        }
      }
    }
  } else {
    return success(/* Lst */Block.__(3, [/* [] */0]), s);
  }
}

exports.map = map;
exports.alt = alt;
exports.success = success;
exports.seq = seq;
/* Node-ReasonParse Not a pure module */
