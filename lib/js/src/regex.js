// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Node$ReasonParse = require("./node.js");

function regex($staropt$star, re, s) {
  var group = $staropt$star ? $staropt$star[0] : 0;
  var resultOption = new RegExp("^" + re.source).exec(s);
  if (resultOption !== null) {
    var match = Belt_Array.get(resultOption, group);
    if (match) {
      var nullableString = match[0];
      if (nullableString == null) {
        return /* Fail */Block.__(1, [Curry._1(Format.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Match not found -- captures[",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */Block.__(11, [
                                        "] is null.",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Match not found -- captures[%d] is null."
                          ]), group)]);
      } else {
        return /* Success */Block.__(0, [
                  /* Str */Block.__(0, [nullableString]),
                  Node$ReasonParse.makeParseData(/* None */0, nullableString, s.slice(nullableString.length), /* () */0)
                ]);
      }
    } else {
      return /* Fail */Block.__(1, ["Match not found -- captures array is empty."]);
    }
  } else {
    return /* Fail */Block.__(1, ["Match not found -- exec failed."]);
  }
}

var partial_arg = (/\s*/);

function maybeWhitespace(param) {
  return regex(/* None */0, partial_arg, param);
}

function string(s) {
  var partial_arg = new RegExp(s);
  return (function (param) {
      return regex(/* None */0, partial_arg, param);
    });
}

var partial_arg$1 = (/\d/);

function digit(param) {
  return regex(/* None */0, partial_arg$1, param);
}

var partial_arg$2 = (/\d+/);

function digits(param) {
  return regex(/* None */0, partial_arg$2, param);
}

var partial_arg$3 = (/[a-zA-Z]/);

function letter(param) {
  return regex(/* None */0, partial_arg$3, param);
}

var partial_arg$4 = (/[a-zA-Z]+/);

function letters(param) {
  return regex(/* None */0, partial_arg$4, param);
}

var partial_arg$5 = (/"([^"]*)"/);

var partial_arg$6 = /* Some */[1];

function quotedString(param) {
  return regex(partial_arg$6, partial_arg$5, param);
}

function intMapper(value) {
  if (typeof value === "number" || value.tag) {
    return value;
  } else {
    return /* Int */Block.__(1, [Caml_format.caml_int_of_string(value[0])]);
  }
}

exports.regex = regex;
exports.maybeWhitespace = maybeWhitespace;
exports.string = string;
exports.digit = digit;
exports.digits = digits;
exports.letter = letter;
exports.letters = letters;
exports.quotedString = quotedString;
exports.intMapper = intMapper;
/* partial_arg Not a pure module */
