// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Node$ReasonParse = require("./node.js");

function regex($staropt$star, re, s) {
  var group = $staropt$star ? $staropt$star[0] : 0;
  var resultOption = new RegExp("^" + re.source).exec(s);
  if (resultOption !== null) {
    var match = Belt_Array.get(resultOption, 0);
    var match$1 = Belt_Array.get(resultOption, group);
    if (match) {
      if (match$1) {
        var nullableMatchGroup = match$1[0];
        var nullableMatch = match[0];
        if (nullableMatch == null) {
          return /* Fail */Block.__(1, ["Match not found -- capture group 0 is null."]);
        } else if (nullableMatchGroup == null) {
          return /* Fail */Block.__(1, [Curry._1(Format.sprintf(/* Format */[
                              /* String_literal */Block.__(11, [
                                  "Match not found -- capture group ",
                                  /* Int */Block.__(4, [
                                      /* Int_d */0,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* String_literal */Block.__(11, [
                                          " is null.",
                                          /* End_of_format */0
                                        ])
                                    ])
                                ]),
                              "Match not found -- capture group %d is null."
                            ]), group)]);
        } else {
          return /* Success */Block.__(0, [
                    /* Str */Block.__(0, [nullableMatchGroup]),
                    Node$ReasonParse.makeParseData(/* None */0, nullableMatch, s.slice(nullableMatch.length), /* () */0)
                  ]);
        }
      } else {
        return /* Fail */Block.__(1, [Curry._1(Format.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Capture group ",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */Block.__(11, [
                                        " is undefined.",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Capture group %d is undefined."
                          ]), group)]);
      }
    } else {
      return /* Fail */Block.__(1, ["Match not found -- captures array is empty."]);
    }
  } else {
    return /* Fail */Block.__(1, ["Match not found -- exec failed."]);
  }
}

var partial_arg = (/\s*/);

function maybeWhitespace(param) {
  return regex(/* None */0, partial_arg, param);
}

function string(s) {
  var partial_arg = new RegExp(s);
  return (function (param) {
      return regex(/* None */0, partial_arg, param);
    });
}

var partial_arg$1 = (/\d/);

function digit(param) {
  return regex(/* None */0, partial_arg$1, param);
}

var partial_arg$2 = (/\d+/);

function digits(param) {
  return regex(/* None */0, partial_arg$2, param);
}

var partial_arg$3 = (/[a-zA-Z]/);

function letter(param) {
  return regex(/* None */0, partial_arg$3, param);
}

var partial_arg$4 = (/[a-zA-Z]+/);

function letters(param) {
  return regex(/* None */0, partial_arg$4, param);
}

function intMapper(value) {
  if (typeof value === "number" || value.tag) {
    return value;
  } else {
    return /* Int */Block.__(1, [Caml_format.caml_int_of_string(value[0])]);
  }
}

function floatMapper(value) {
  if (typeof value === "number" || value.tag) {
    return value;
  } else {
    return /* Flt */Block.__(2, [Caml_format.caml_float_of_string(value[0])]);
  }
}

function map($staropt$star, $staropt$star$1, p, s) {
  var f = $staropt$star ? $staropt$star[0] : (function (x) {
        return x;
      });
  var g = $staropt$star$1 ? $staropt$star$1[0] : (function (x) {
        return x;
      });
  var x = Curry._1(p, s);
  if (x.tag) {
    return x;
  } else {
    return /* Success */Block.__(0, [
              Curry._1(f, x[0]),
              Curry._1(g, x[1])
            ]);
  }
}

var partial_arg$5 = /* Some */[intMapper];

function integer(param) {
  return map(partial_arg$5, /* None */0, digits, param);
}

var partial_arg$6 = /* Some */[floatMapper];

function arg(param, param$1, param$2) {
  return map(partial_arg$6, param, param$1, param$2);
}

var partial_arg$7 = (/\d+\.\d+/);

var $$float = (function (eta) {
      return Curry._2(arg, /* None */0, eta);
    })((function (param) {
        return regex(/* None */0, partial_arg$7, param);
      }));

exports.regex = regex;
exports.maybeWhitespace = maybeWhitespace;
exports.string = string;
exports.digit = digit;
exports.digits = digits;
exports.letter = letter;
exports.letters = letters;
exports.intMapper = intMapper;
exports.floatMapper = floatMapper;
exports.map = map;
exports.integer = integer;
exports.$$float = $$float;
/* partial_arg Not a pure module */
