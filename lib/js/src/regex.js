// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Node$ReasonParse = require("./node.js");

function regex($staropt$star, re, s) {
  var group = $staropt$star ? $staropt$star[0] : 0;
  var resultOption = new RegExp("^" + re.source).exec(s);
  if (resultOption !== null) {
    console.log(resultOption);
    var match = Belt_Array.get(resultOption, group);
    if (match) {
      var nullableString = match[0];
      if (nullableString == null) {
        return /* Fail */Block.__(1, ["Match not found -- captures[0] is null."]);
      } else {
        return /* Node */Block.__(0, [/* record */[
                    /* value : Str */Block.__(0, [nullableString]),
                    /* parseData */Node$ReasonParse.makeParseData(/* None */0, nullableString, s.slice(nullableString.length), /* () */0)
                  ]]);
      }
    } else {
      return /* Fail */Block.__(1, ["Match not found -- captures array is empty."]);
    }
  } else {
    return /* Fail */Block.__(1, ["Match not found -- exec failed."]);
  }
}

var partial_arg = (/\s*/);

function maybeWhitespace(param) {
  return regex(/* None */0, partial_arg, param);
}

function string(s) {
  var partial_arg = new RegExp(s);
  return (function (param) {
      return regex(/* None */0, partial_arg, param);
    });
}

var partial_arg$1 = (/\d/);

function digit(param) {
  return regex(/* None */0, partial_arg$1, param);
}

var partial_arg$2 = (/\d+/);

function digits(param) {
  return regex(/* None */0, partial_arg$2, param);
}

var partial_arg$3 = (/[a-zA-Z]/);

function letter(param) {
  return regex(/* None */0, partial_arg$3, param);
}

var partial_arg$4 = (/[a-zA-Z]+/);

function letters(param) {
  return regex(/* None */0, partial_arg$4, param);
}

var partial_arg$5 = (/"([^"]*)"/);

var partial_arg$6 = /* Some */[1];

function quotedString(param) {
  return regex(partial_arg$6, partial_arg$5, param);
}

function intMapper(node) {
  var v = node[/* value */0];
  var value;
  value = typeof v === "number" || v.tag ? v : /* Int */Block.__(1, [Caml_format.caml_int_of_string(v[0])]);
  return /* record */[
          /* value */value,
          /* parseData */node[/* parseData */1]
        ];
}

exports.regex = regex;
exports.maybeWhitespace = maybeWhitespace;
exports.string = string;
exports.digit = digit;
exports.digits = digits;
exports.letter = letter;
exports.letters = letters;
exports.quotedString = quotedString;
exports.intMapper = intMapper;
/* partial_arg Not a pure module */
