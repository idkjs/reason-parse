// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Node$ReasonParse = require("./node.js");
var Combs$ReasonParse = require("./combs.js");
var Regex$ReasonParse = require("./regex.js");

var Break = Caml_exceptions.create("Pstream-ReasonParse.Break");

function reduceStream(reducer, init, stream) {
  var accRef = [init];
  try {
    Stream.iter((function (x) {
            accRef[0] = Curry._3(reducer, accRef[0], x, Stream.count(stream));
            return /* () */0;
          }), stream);
    return accRef[0];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Break) {
      return /* tuple */[
              exn[1],
              exn[2]
            ];
    } else {
      throw exn;
    }
  }
}

function altReducer(param, parser, _) {
  var string = param[0];
  var success = Curry._1(parser, string);
  if (success.tag) {
    return /* tuple */[
            string,
            param[1]
          ];
  } else {
    throw [
          Break,
          string,
          success
        ];
  }
}

function alt(ps, s) {
  return reduceStream(altReducer, /* tuple */[
                s,
                /* Fail */Block.__(1, ["All the parsers failed."])
              ], Stream.of_list(ps))[1];
}

function extractList(value) {
  if (typeof value === "number" || value.tag !== 3) {
    return Js_exn.raiseError("Don't pass a non-list to extractList!");
  } else {
    return value[0];
  }
}

function seqReducer(nParsers, param, parser, count) {
  var result = param[1];
  var string = param[0];
  var match = Curry._1(parser, string);
  if (result.tag) {
    throw [
          Break,
          string,
          /* Fail */Block.__(1, ["You shouldn't be here!"])
        ];
  } else if (match.tag) {
    throw [
          Break,
          string,
          /* Fail */Block.__(1, [Curry._3(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    " of ",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            " failed: ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "Parser %d of %d failed: %s"
                      ]), count, nParsers, match[0])])
        ];
  } else {
    var parseData = match[1];
    return /* tuple */[
            parseData[/* rest */1],
            /* Success */Block.__(0, [
                /* Lst */Block.__(3, [/* :: */[
                      match[0],
                      extractList(result[0])
                    ]]),
                /* record */[
                  /* match */result[1][/* match */0] + parseData[/* match */0],
                  /* rest */parseData[/* rest */1],
                  /* parserName */parseData[/* parserName */2]
                ]
              ])
          ];
  }
}

function seq(ps, s) {
  var partial_arg = List.length(ps);
  return reduceStream((function (param, param$1, param$2) {
                  return seqReducer(partial_arg, param, param$1, param$2);
                }), /* tuple */[
                s,
                Combs$ReasonParse.success(/* Lst */Block.__(3, [/* [] */0]), s)
              ], Stream.of_list(ps))[1];
}

var partial_arg = /* Some */[Regex$ReasonParse.intMapper];

function q(param) {
  return Combs$ReasonParse.map(partial_arg, /* None */0, Regex$ReasonParse.digits, param);
}

var partial_arg_001 = /* :: */[
  q,
  /* :: */[
    Regex$ReasonParse.maybeWhitespace,
    /* :: */[
      q,
      /* [] */0
    ]
  ]
];

var partial_arg$1 = /* :: */[
  Regex$ReasonParse.letters,
  partial_arg_001
];

function pqr(param) {
  return seq(partial_arg$1, param);
}

console.log(Node$ReasonParse.stringOfResult(pqr("efg123   436***")));

var p = Regex$ReasonParse.letters;

var r = Regex$ReasonParse.maybeWhitespace;

exports.Break = Break;
exports.reduceStream = reduceStream;
exports.altReducer = altReducer;
exports.alt = alt;
exports.extractList = extractList;
exports.seqReducer = seqReducer;
exports.seq = seq;
exports.p = p;
exports.q = q;
exports.r = r;
exports.pqr = pqr;
/*  Not a pure module */
