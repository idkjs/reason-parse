// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function hd(stream) {
  try {
    return /* Some */[Stream.next(stream)];
  }
  catch (exn){
    return /* None */0;
  }
}

function red(reducer, _acc, stream) {
  while(true) {
    var acc = _acc;
    var match = hd(stream);
    if (match) {
      _acc = Curry._2(reducer, acc, match[0]);
      continue ;
      
    } else {
      return acc;
    }
  };
}

var Break = Caml_exceptions.create("Pstream-ReasonParse.Break");

function altt(ps, s) {
  var stream = Stream.of_list(ps);
  var f = function (acc, p) {
    try {
      var success = Curry._1(p, s);
      if (success.tag) {
        return acc;
      } else {
        throw [
              Break,
              success
            ];
      }
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Break) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  };
  return red(f, /* Fail */Block.__(1, ["alt failed: none of the parsers matched."]), stream);
}

function seqUnwrapped(stream, s) {
  var f = function (param, p) {
    var pData = param[3];
    var vList = param[2];
    var n = param[1];
    var success = Curry._1(p, s);
    if (success.tag) {
      return /* tuple */[
              /* Some */[success],
              n,
              vList,
              pData
            ];
    } else {
      var parseData = success[1];
      return /* tuple */[
              /* Some */[success],
              n + 1 | 0,
              /* :: */[
                success[0],
                vList
              ],
              /* record */[
                /* match */pData[/* match */0] + parseData[/* match */0],
                /* rest */parseData[/* rest */1],
                /* parserName */parseData[/* parserName */2]
              ]
            ];
    }
  };
  var init_003 = /* record */[
    /* match */"",
    /* rest */s,
    /* parserName : None */0
  ];
  var init = /* tuple */[
    /* None */0,
    0,
    /* [] */0,
    init_003
  ];
  return red(f, init, stream);
}

function seq(ps, s) {
  var match = seqUnwrapped(Stream.of_list(ps), s);
  var pData = match[3];
  var vList = match[2];
  var lastResult = match[0];
  if (lastResult) {
    var fail = lastResult[0];
    if (fail.tag) {
      return fail;
    } else {
      return /* Success */Block.__(0, [
                /* Lst */Block.__(3, [vList]),
                pData
              ]);
    }
  } else {
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [vList]),
              pData
            ]);
  }
}

function zOrMore(p, s) {
  var stream = Stream.from((function () {
          return p;
        }));
  var match = seqUnwrapped(stream, s);
  return /* Success */Block.__(0, [
            /* Lst */Block.__(3, [match[2]]),
            match[3]
          ]);
}

function oneOrMore(p, s) {
  var stream = Stream.from((function () {
          return p;
        }));
  var match = seqUnwrapped(stream, s);
  var lastResult = match[0];
  var match$1 = +(match[1] >= 1);
  if (match$1 !== 0) {
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [match[2]]),
              match[3]
            ]);
  } else if (lastResult) {
    return lastResult[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "pstream.re",
            68,
            16
          ]
        ];
  }
}

var ParseFailureExn = Caml_exceptions.create("Pstream-ReasonParse.ParseFailureExn");

function tillFailure(stream, string) {
  var f = function (param, parser) {
    var rest = param[1];
    var list = param[0];
    var match = Curry._1(parser, rest);
    if (match.tag) {
      throw [
            ParseFailureExn,
            list,
            rest,
            match[0]
          ];
    } else {
      var parseData = match[1];
      return /* tuple */[
              /* :: */[
                /* tuple */[
                  match[0],
                  parseData
                ],
                list
              ],
              parseData[/* rest */1]
            ];
    }
  };
  try {
    var match = red(f, /* tuple */[
          /* [] */0,
          string
        ], stream);
    return /* tuple */[
            match[0],
            match[1],
            /* EndOfStream */Block.__(0, [Stream.count(stream)])
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === ParseFailureExn) {
      return /* tuple */[
              exn[1],
              exn[2],
              /* ParseFailure */Block.__(1, [
                  Stream.count(stream),
                  exn[3]
                ])
            ];
    } else {
      throw exn;
    }
  }
}

function mergeParseData(list) {
  if (list) {
    var x = list[0];
    return /* record */[
            /* match */mergeParseData(list[1])[/* match */0] + x[/* match */0],
            /* rest */x[/* rest */1],
            /* parserName */x[/* parserName */2]
          ];
  } else {
    return /* record */[
            /* match */"",
            /* rest */"",
            /* parserName : None */0
          ];
  }
}

function seqqq(ps, s) {
  var match = tillFailure(Stream.of_list(ps), s);
  var match$1 = match[2];
  if (match$1.tag) {
    return /* Fail */Block.__(1, [Curry._3(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    " of ",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            " failed: ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "Parser %d of %d failed: %s"
                      ]), match$1[0], List.length(ps), match$1[1])]);
  } else {
    var match$2 = List.split(match[0]);
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [List.rev(match$2[0])]),
              mergeParseData(match$2[1])
            ]);
  }
}

function atMost(n, parser, string) {
  var stream = Stream.from((function (k) {
          var match = +(k < n);
          if (match !== 0) {
            return /* Some */[parser];
          } else {
            return /* None */0;
          }
        }));
  var match = tillFailure(stream, string);
  var match$1 = List.split(match[0]);
  return /* Success */Block.__(0, [
            /* Lst */Block.__(3, [List.rev(match$1[0])]),
            mergeParseData(match$1[1])
          ]);
}

function atLeast(n, parser, string) {
  var stream = Stream.from((function () {
          return /* Some */[parser];
        }));
  var match = tillFailure(stream, string);
  var match$1 = match[2];
  if (match$1.tag) {
    var count = match$1[0];
    if (count >= n) {
      var match$2 = List.split(match[0]);
      return /* Success */Block.__(0, [
                /* Lst */Block.__(3, [List.rev(match$2[0])]),
                mergeParseData(match$2[1])
              ]);
    } else {
      return /* Fail */Block.__(1, [Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "Only ",
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */Block.__(11, [
                                      " instances matched.",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Only %d instances matched."
                        ]), count)]);
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "pstream.re",
            131,
            30
          ]
        ];
  }
}

function reduce($staropt$star, reducer, init, stream) {
  var $$break = $staropt$star ? $staropt$star[0] : (function (_, _$1, _$2) {
        return /* false */0;
      });
  var acc = init;
  try {
    var x = Stream.next(stream);
    while(!Curry._3($$break, acc, x, Stream.count(stream))) {
      acc = Curry._3(reducer, acc, x, Stream.count(stream));
      x = Stream.next(stream);
    };
    return acc;
  }
  catch (exn){
    if (exn === Stream.Failure) {
      return acc;
    } else {
      throw exn;
    }
  }
}

function alt(ps, s) {
  return reduce(/* Some */[(function (acc, _, _$1) {
                  if (acc.tag) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
                })], (function (_, parser, _$1) {
                return Curry._1(parser, s);
              }), /* Fail */Block.__(1, ["All the parsers failed."]), Stream.of_list(ps));
}

function seqReducer(param, parser, _) {
  var prevParseData = param[2];
  var valueListLength = param[1];
  var valueList = param[0];
  var match = Curry._1(parser, prevParseData[/* rest */1]);
  if (match.tag) {
    return /* tuple */[
            valueList,
            valueListLength,
            prevParseData
          ];
  } else {
    var parseData = match[1];
    return /* tuple */[
            /* :: */[
              match[0],
              valueList
            ],
            valueListLength + 1 | 0,
            /* record */[
              /* match */prevParseData[/* match */0] + parseData[/* match */0],
              /* rest */parseData[/* rest */1],
              /* parserName */parseData[/* parserName */2]
            ]
          ];
  }
}

function isSuccess(result) {
  if (result.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function zeroOrMore(p, rest) {
  var stream = Stream.from((function () {
          return /* Some */[p];
        }));
  var reducer = function (param, _, _$1) {
    var prevParseData = param[1];
    var match = Curry._1(p, prevParseData[/* rest */1]);
    if (match.tag) {
      throw Stream.Failure;
    } else {
      var parseData = match[1];
      return /* tuple */[
              /* :: */[
                match[0],
                param[0]
              ],
              /* record */[
                /* match */prevParseData[/* match */0] + parseData[/* match */0],
                /* rest */parseData[/* rest */1],
                /* parserName */parseData[/* parserName */2]
              ]
            ];
    }
  };
  var match = reduce(/* Some */[(function (_, _$1, _$2) {
            return /* false */0;
          })], reducer, /* tuple */[
        /* [] */0,
        /* record */[
          /* match */"",
          /* rest */rest,
          /* parserName : None */0
        ]
      ], stream);
  return /* Success */Block.__(0, [
            /* Lst */Block.__(3, [List.rev(match[0])]),
            match[1]
          ]);
}

exports.hd = hd;
exports.red = red;
exports.Break = Break;
exports.altt = altt;
exports.seqUnwrapped = seqUnwrapped;
exports.seq = seq;
exports.zOrMore = zOrMore;
exports.oneOrMore = oneOrMore;
exports.ParseFailureExn = ParseFailureExn;
exports.tillFailure = tillFailure;
exports.mergeParseData = mergeParseData;
exports.seqqq = seqqq;
exports.atMost = atMost;
exports.atLeast = atLeast;
exports.reduce = reduce;
exports.alt = alt;
exports.seqReducer = seqReducer;
exports.isSuccess = isSuccess;
exports.zeroOrMore = zeroOrMore;
/* Format Not a pure module */
