// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Stream = require("bs-platform/lib/js/stream.js");

function hd(stream) {
  try {
    return /* Some */[Stream.next(stream)];
  }
  catch (exn){
    return /* None */0;
  }
}

function reduce(reducer, _acc, stream) {
  while(true) {
    var acc = _acc;
    var match = hd(stream);
    if (match) {
      _acc = Curry._2(reducer, acc, match[0]);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function alt(_parsers, string) {
  while(true) {
    var parsers = _parsers;
    if (parsers) {
      var success = Curry._1(parsers[0], string);
      if (success[0] >= 781116926) {
        _parsers = parsers[1];
        continue ;
        
      } else {
        return success;
      }
    } else {
      return /* `Fail */[
              781116926,
              "None of the parsers matched"
            ];
    }
  };
}

function nextOpt(stream) {
  try {
    return /* Some */[Stream.next(stream)];
  }
  catch (exn){
    if (exn === Stream.Failure) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function tillFailure(stream, string) {
  var match = nextOpt(stream);
  if (match) {
    var success = Curry._1(match[0], string);
    if (success[0] >= 781116926) {
      return /* tuple */[
              /* [] */0,
              /* Some */[success]
            ];
    } else {
      var match$1 = tillFailure(stream, success[1][1][/* remainder */1]);
      return /* tuple */[
              /* :: */[
                success,
                match$1[0]
              ],
              match$1[1]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* None */0
          ];
  }
}

function mergeParseData(initialString, list) {
  if (list) {
    var x = list[0];
    return /* record */[
            /* match */mergeParseData(initialString, list[1])[/* match */0] + x[/* match */0],
            /* remainder */x[/* remainder */1]
          ];
  } else {
    return /* record */[
            /* match */"",
            /* remainder */initialString
          ];
  }
}

function tillFailureMerged(stream, string) {
  var match = tillFailure(stream, string);
  var match$1 = List.split(List.map((function (param) {
              var match = param[1];
              return /* tuple */[
                      match[0],
                      match[1]
                    ];
            }), match[0]));
  return /* tuple */[
          List.rev(match$1[0]),
          mergeParseData(string, match$1[1]),
          match[1]
        ];
}

function stream(stream$1, string) {
  var match = tillFailureMerged(stream$1, string);
  var match$1 = match[2];
  if (match$1) {
    return /* `Fail */[
            781116926,
            /* :: */[
              Curry._1(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser `Stream failure at parser index ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "Parser `Stream failure at parser index %d"
                      ]), Stream.count(stream$1)),
              match$1[0][1]
            ]
          ];
  } else {
    return /* `Success */[
            94326179,
            /* tuple */[
              /* `List */[
                848054398,
                match[0]
              ],
              match[1]
            ]
          ];
  }
}

function seq(ps) {
  var partial_arg = Stream.of_list(ps);
  return (function (param) {
      return stream(partial_arg, param);
    });
}

function appendRange(list) {
  return List.mapi((function (i, a) {
                return /* tuple */[
                        i,
                        a
                      ];
              }), list);
}

function filteri(predicate, list) {
  return List.map((function (prim) {
                return prim[1];
              }), List.filter((function (param) {
                      return Curry._2(predicate, param[0], param[1]);
                    }))(appendRange(list)));
}

function keep(indices, ps, s) {
  var partial_arg = Stream.of_list(ps);
  var fail = (function (param) {
        return stream(partial_arg, param);
      })(s);
  if (typeof fail === "number") {
    return fail;
  } else if (fail[0] !== 94326179) {
    return fail;
  } else {
    var match = fail[1];
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      return fail;
    } else if (match$1[0] !== 848054398) {
      return fail;
    } else {
      var filteredList = filteri((function (i, _) {
              return List.mem(i, indices);
            }), match$1[1]);
      return /* `Success */[
              94326179,
              /* tuple */[
                /* `List */[
                  848054398,
                  filteredList
                ],
                match[1]
              ]
            ];
    }
  }
}

function keepNth(n) {
  var partial_arg = /* :: */[
    n,
    /* [] */0
  ];
  return (function (param, param$1) {
      return keep(partial_arg, param, param$1);
    });
}

function keepFirst() {
  var partial_arg = /* :: */[
    0,
    /* [] */0
  ];
  return (function (param, param$1) {
      return keep(partial_arg, param, param$1);
    });
}

function keepLast(ps) {
  var n = List.length(ps) - 1 | 0;
  var partial_arg = /* :: */[
    n,
    /* [] */0
  ];
  return (function (param) {
      var param$1 = ps;
      var param$2 = param;
      return keep(partial_arg, param$1, param$2);
    });
}

exports.hd = hd;
exports.reduce = reduce;
exports.alt = alt;
exports.nextOpt = nextOpt;
exports.tillFailure = tillFailure;
exports.mergeParseData = mergeParseData;
exports.tillFailureMerged = tillFailureMerged;
exports.stream = stream;
exports.seq = seq;
exports.appendRange = appendRange;
exports.filteri = filteri;
exports.keep = keep;
exports.keepNth = keepNth;
exports.keepFirst = keepFirst;
exports.keepLast = keepLast;
/* Format Not a pure module */
