// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Node$ReasonParse = require("./node.js");
var Combs$ReasonParse = require("./combs.js");
var Regex$ReasonParse = require("./regex.js");

function reduce($staropt$star, reducer, init, stream) {
  var $$break = $staropt$star ? $staropt$star[0] : (function (_, _$1, _$2) {
        return /* false */0;
      });
  var acc = init;
  try {
    var x = Stream.next(stream);
    while(!Curry._3($$break, acc, x, Stream.count(stream))) {
      acc = Curry._3(reducer, acc, x, Stream.count(stream));
      x = Stream.next(stream);
    };
    return acc;
  }
  catch (exn){
    if (exn === Stream.Failure) {
      return acc;
    } else {
      throw exn;
    }
  }
}

function alt(ps, s) {
  return reduce(/* Some */[(function (acc, _, _$1) {
                  if (acc.tag) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
                })], (function (_, parser, _$1) {
                return Curry._1(parser, s);
              }), /* Fail */Block.__(1, ["All the parsers failed."]), Stream.of_list(ps));
}

function seqReducer(param, parser, _) {
  var prevParseData = param[2];
  var valueListLength = param[1];
  var valueList = param[0];
  var match = Curry._1(parser, prevParseData[/* rest */1]);
  if (match.tag) {
    return /* tuple */[
            valueList,
            valueListLength,
            prevParseData
          ];
  } else {
    var parseData = match[1];
    return /* tuple */[
            /* :: */[
              match[0],
              valueList
            ],
            valueListLength + 1 | 0,
            /* record */[
              /* match */prevParseData[/* match */0] + parseData[/* match */0],
              /* rest */parseData[/* rest */1],
              /* parserName */parseData[/* parserName */2]
            ]
          ];
  }
}

function seq(ps, rest) {
  var stream = Stream.of_list(ps);
  var match = reduce(/* Some */[(function (param, _, count) {
            return +(param[1] !== (count - 1 | 0));
          })], seqReducer, /* tuple */[
        /* [] */0,
        0,
        /* record */[
          /* match */"",
          /* rest */rest,
          /* parserName : None */0
        ]
      ], stream);
  var valueListLength = match[1];
  var count = Stream.count(stream);
  if (valueListLength === count) {
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [List.rev(match[0])]),
              match[2]
            ]);
  } else {
    var message = Curry._2(Format.sprintf(/* Format */[
              /* String_literal */Block.__(11, [
                  "Parser ",
                  /* Int */Block.__(4, [
                      /* Int_d */0,
                      /* No_padding */0,
                      /* No_precision */0,
                      /* String_literal */Block.__(11, [
                          " of ",
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* String_literal */Block.__(11, [
                                  " failed.",
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ])
                ]),
              "Parser %d of %d failed."
            ]), valueListLength + 1 | 0, count);
    return /* Fail */Block.__(1, [message]);
  }
}

function zeroOrMore(p, rest) {
  var stream = Stream.from((function () {
          return /* Some */[p];
        }));
  var reducer = function (param, _, _$1) {
    var prevParseData = param[1];
    var match = Curry._1(p, prevParseData[/* rest */1]);
    if (match.tag) {
      throw Stream.Failure;
    } else {
      var parseData = match[1];
      return /* tuple */[
              /* :: */[
                match[0],
                param[0]
              ],
              /* record */[
                /* match */prevParseData[/* match */0] + parseData[/* match */0],
                /* rest */parseData[/* rest */1],
                /* parserName */parseData[/* parserName */2]
              ]
            ];
    }
  };
  var match = reduce(/* Some */[(function (_, _$1, _$2) {
            return /* false */0;
          })], reducer, /* tuple */[
        /* [] */0,
        /* record */[
          /* match */"",
          /* rest */rest,
          /* parserName : None */0
        ]
      ], stream);
  return /* Success */Block.__(0, [
            /* Lst */Block.__(3, [List.rev(match[0])]),
            match[1]
          ]);
}

var partial_arg = /* Some */[Regex$ReasonParse.intMapper];

function q(param) {
  return Combs$ReasonParse.map(partial_arg, /* None */0, Regex$ReasonParse.digits, param);
}

var partial_arg_001 = /* :: */[
  q,
  /* :: */[
    Regex$ReasonParse.maybeWhitespace,
    /* [] */0
  ]
];

var partial_arg$1 = /* :: */[
  Regex$ReasonParse.letters,
  partial_arg_001
];

function pqr(param) {
  return seq(partial_arg$1, param);
}

function ltrs(param) {
  return zeroOrMore(Regex$ReasonParse.letter, param);
}

var result = pqr("efg12!3   436***");

console.log(Node$ReasonParse.stringOfResult(ltrs("abcdef123456")));

var p = Regex$ReasonParse.letters;

var r = Regex$ReasonParse.maybeWhitespace;

exports.reduce = reduce;
exports.alt = alt;
exports.seqReducer = seqReducer;
exports.seq = seq;
exports.zeroOrMore = zeroOrMore;
exports.p = p;
exports.q = q;
exports.r = r;
exports.pqr = pqr;
exports.ltrs = ltrs;
exports.result = result;
/* result Not a pure module */
