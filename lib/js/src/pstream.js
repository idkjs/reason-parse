// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function hd(stream) {
  try {
    return /* Some */[Stream.next(stream)];
  }
  catch (exn){
    return /* None */0;
  }
}

function reduce(reducer, _acc, stream) {
  while(true) {
    var acc = _acc;
    var match = hd(stream);
    if (match) {
      _acc = Curry._2(reducer, acc, match[0]);
      continue ;
      
    } else {
      return acc;
    }
  };
}

var Break = Caml_exceptions.create("Pstream-ReasonParse.Break");

function alt(ps, s) {
  var stream = Stream.of_list(ps);
  var f = function (acc, p) {
    try {
      var success = Curry._1(p, s);
      if (success.tag) {
        return acc;
      } else {
        throw [
              Break,
              success
            ];
      }
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Break) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  };
  return reduce(f, /* Fail */Block.__(1, ["alt failed: none of the parsers matched."]), stream);
}

var ParseFailureExn = Caml_exceptions.create("Pstream-ReasonParse.ParseFailureExn");

function tillFailure(stream, string) {
  var f = function (param, parser) {
    var rest = param[1];
    var list = param[0];
    var match = Curry._1(parser, rest);
    if (match.tag) {
      throw [
            ParseFailureExn,
            list,
            rest,
            match[0]
          ];
    } else {
      var parseData = match[1];
      return /* tuple */[
              /* :: */[
                /* tuple */[
                  match[0],
                  parseData
                ],
                list
              ],
              parseData[/* rest */1]
            ];
    }
  };
  try {
    var match = reduce(f, /* tuple */[
          /* [] */0,
          string
        ], stream);
    return /* tuple */[
            match[0],
            match[1],
            /* EndOfStream */Block.__(0, [Stream.count(stream)])
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === ParseFailureExn) {
      return /* tuple */[
              exn[1],
              exn[2],
              /* ParseFailure */Block.__(1, [
                  Stream.count(stream),
                  exn[3]
                ])
            ];
    } else {
      throw exn;
    }
  }
}

function mergeParseData($staropt$star, initialString, list) {
  var parserName = $staropt$star ? $staropt$star[0] : /* None */0;
  if (list) {
    var x = list[0];
    return /* record */[
            /* match */mergeParseData(/* Some */[parserName], initialString, list[1])[/* match */0] + x[/* match */0],
            /* rest */x[/* rest */1],
            /* parserName */x[/* parserName */2]
          ];
  } else {
    return /* record */[
            /* match */"",
            /* rest */initialString,
            /* parserName */parserName
          ];
  }
}

function stream(stream$1, string) {
  var match = tillFailure(stream$1, string);
  var match$1 = match[2];
  if (match$1.tag) {
    return /* Fail */Block.__(1, [Curry._2(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser failure at stream index ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    ": ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "Parser failure at stream index %d: %s"
                      ]), match$1[0], match$1[1])]);
  } else {
    var match$2 = List.split(match[0]);
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [List.rev(match$2[0])]),
              mergeParseData(/* None */0, string, match$2[1])
            ]);
  }
}

function seq(ps, s) {
  var match = tillFailure(Stream.of_list(ps), s);
  var match$1 = match[2];
  if (match$1.tag) {
    return /* Fail */Block.__(1, [Curry._3(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Parser ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    " of ",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            " failed: ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "Parser %d of %d failed: %s"
                      ]), match$1[0], List.length(ps), match$1[1])]);
  } else {
    var match$2 = List.split(match[0]);
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [List.rev(match$2[0])]),
              mergeParseData(/* None */0, s, match$2[1])
            ]);
  }
}

function keepNth(n, ps, s) {
  var match = seq(ps, s);
  if (match.tag) {
    return /* Fail */Block.__(1, [match[0]]);
  } else {
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "pstream.re",
              92,
              21
            ]
          ];
    } else if (match$1.tag === 3) {
      var match$2 = Belt_List.get(match$1[0], n);
      if (match$2) {
        return /* Success */Block.__(0, [
                  match$2[0],
                  match[1]
                ]);
      } else {
        return /* Fail */Block.__(1, [Curry._2(Format.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Index out of range: 0-based index = ",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */Block.__(11, [
                                        ", length of parser sequence = ",
                                        /* Int */Block.__(4, [
                                            /* Int_d */0,
                                            /* No_padding */0,
                                            /* No_precision */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ]),
                            "Index out of range: 0-based index = %d, length of parser sequence = %d"
                          ]), n, List.length(ps))]);
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "pstream.re",
              92,
              21
            ]
          ];
    }
  }
}

function keepFirst(param, param$1) {
  return keepNth(0, param, param$1);
}

function keepLast(ps) {
  var partial_arg = List.length(ps) - 1 | 0;
  return (function (param) {
      return keepNth(partial_arg, ps, param);
    });
}

function between(p, q, r) {
  var partial_arg_001 = /* :: */[
    q,
    /* :: */[
      r,
      /* [] */0
    ]
  ];
  var partial_arg = /* :: */[
    p,
    partial_arg_001
  ];
  return (function (param) {
      return keepNth(1, partial_arg, param);
    });
}

function successes($staropt$star, stream, string) {
  var atLeast = $staropt$star ? $staropt$star[0] : 0;
  var match = tillFailure(stream, string);
  var list = match[0];
  if (List.length(list) >= atLeast) {
    console.log(Curry._2(Format.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "count: ",
                      /* Int */Block.__(4, [
                          /* Int_d */0,
                          /* No_padding */0,
                          /* No_precision */0,
                          /* String_literal */Block.__(11, [
                              ", atLeast: ",
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "count: %d, atLeast: %d"
                ]), match[2][0], atLeast));
    var match$1 = List.split(list);
    return /* Success */Block.__(0, [
              /* Lst */Block.__(3, [List.rev(match$1[0])]),
              mergeParseData(/* None */0, string, match$1[1])
            ]);
  } else {
    return /* Fail */Block.__(1, [Curry._2(Format.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Only ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    " instance(s) matched. Needed to match at least ",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            " instance(s).",
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "Only %d instance(s) matched. Needed to match at least %d instance(s)."
                      ]), List.length(list), atLeast)]);
  }
}

function _times($staropt$star, atMost, parser) {
  var atLeast = $staropt$star ? $staropt$star[0] : 0;
  var partial_arg = Stream.from((function (n) {
          if (atMost) {
            if (n < atMost[0]) {
              return /* Some */[parser];
            } else {
              return /* None */0;
            }
          } else {
            return /* Some */[parser];
          }
        }));
  var partial_arg$1 = /* Some */[atLeast];
  return (function (param) {
      return successes(partial_arg$1, partial_arg, param);
    });
}

function zeroOrMore(parser) {
  return _times(/* Some */[0], /* None */0, parser);
}

function oneOrMore(parser) {
  return _times(/* Some */[1], /* None */0, parser);
}

function atLeast(atLeast$1, parser) {
  return _times(/* Some */[atLeast$1], /* None */0, parser);
}

function atMost(atMost$1) {
  var partial_arg = /* Some */[atMost$1];
  var partial_arg$1 = /* Some */[0];
  return (function (param) {
      return _times(partial_arg$1, partial_arg, param);
    });
}

function atLeastAtMost(atLeast, atMost) {
  var partial_arg = /* Some */[atMost];
  var partial_arg$1 = /* Some */[atLeast];
  return (function (param) {
      return _times(partial_arg$1, partial_arg, param);
    });
}

function nTimes(n) {
  return atLeastAtMost(n, n);
}

function sepBy(separator, parser, string) {
  var stream = Stream.from((function (n) {
          var match = +(n === 0);
          if (match !== 0) {
            return /* Some */[parser];
          } else {
            return /* Some */[keepLast(/* :: */[
                          separator,
                          /* :: */[
                            parser,
                            /* [] */0
                          ]
                        ])];
          }
        }));
  return successes(/* Some */[0], stream, string);
}

exports.hd = hd;
exports.reduce = reduce;
exports.Break = Break;
exports.alt = alt;
exports.ParseFailureExn = ParseFailureExn;
exports.tillFailure = tillFailure;
exports.mergeParseData = mergeParseData;
exports.stream = stream;
exports.seq = seq;
exports.keepNth = keepNth;
exports.keepFirst = keepFirst;
exports.keepLast = keepLast;
exports.between = between;
exports.successes = successes;
exports._times = _times;
exports.zeroOrMore = zeroOrMore;
exports.oneOrMore = oneOrMore;
exports.atLeast = atLeast;
exports.atMost = atMost;
exports.atLeastAtMost = atLeastAtMost;
exports.nTimes = nTimes;
exports.sepBy = sepBy;
/* Format Not a pure module */
